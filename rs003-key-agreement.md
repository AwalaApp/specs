# Relaynet Channel Session Protocol

- Id: RS-003.
- Status: Placeholder.
- Type: Implementation.

## Abstract

This document describes an asynchronous key agreement and management protocol to establish and maintain secure sessions in bidirectional [messaging channels](rs000-core.md#messaging-protocols). Its purpose is to add perfect forward secrecy, [future secrecy](https://signal.org/blog/advanced-ratcheting/) and replay attack mitigation to Relaynet.

## Introduction

Relaynet Core defines messaging channels that use end-to-end encryption using public key cryptography to guarantee confidentiality, integrity and non-repudiation. But since messages are always encrypted using the same keys, compromising the keys will compromise past and future messages -- In other words, Relaynet Core does not offer perfect forward secrecy.

This protocol extends Relaynet to add perfect forward secrecy, future secrecy and replay attack mitigation. It is heavily based on the [Extended Triple Diffie-Hellman protocol](https://signal.org/docs/specifications/x3dh/) and the [double ratchet algorithm](https://signal.org/docs/specifications/doubleratchet/) from the Signal project, with some notable differences:

- There is no central server that can provide certificates or public keys for any node in Relaynet, but that is not necessary because peers always have each other's certificates.
- There must be multiple ephemeral keys that are valid at any point in time and ephemeral keys can be reused, so it can work in a disruption-tolerant network where messages can arrive late or out of order, or they may be lost. 
- Elliptic Curve Cryptography is not required. RSA is also allowed to lower the barrier to adoption.

## Roles

This document refers to the two nodes in the sessions as _Alice_ and _Bob_. It assumes that Alice wants to initiate a session with Bob, and that she already has has Bob's public key.

Since this protocol applies to sessions on Relaynet channels, Alice and Bob would either be endpoints or gateways, but not a combination of the two -- That is, this protocol does not apply to [bindings](rs000-core.md#message-transport-bindings).

## Parameters

A channel implementation MUST define the following parameters:

- Algorithm: RSA or a curve like `Curve25519` or `Curve448`.
- Hash: A 256- or 512-bit hash function (e.g. SHA-256 or SHA-512).
- Channel id: An ASCII string identifying the channel.

For example, a Relaynet service may configure its endpoints to use RSA with 4096-bit keys, SHA-512 as the hash function and `My Service` as the channel.

## Notation

- _X || Y_ denotes the concatenation of byte sequences X and Y.
- _LK<sub>A</sub>_ and _LK<sub>B</sub>_ denote the long-term key pairs for Alice and Bob, respectively. These are the keys used in their corresponding Relaynet PKI certificates.
- _LK<sub>A</sub><sup>private</sup>_ and _LK<sub>B</sub><sup>private</sup>_ denote the private keys in LK<sub>A</sub> and LK<sub>B</sub>, respectively.
- _LK<sub>A</sub><sup>public</sup>_ and _LK<sub>B</sub><sup>public</sup>_ denote the public keys in LK<sub>A</sub> and LK<sub>B</sub>, respectively.
- _EK<sub>A,n</sub>_ and _EK<sub>B,m</sub>_ denote ephemeral key pairs generated by Alice and Bob, respectively.
- _EK<sub>A,n</sub><sup>private</sup>_ and _EK<sub>B,m</sub><sup>private</sup>_ denote the private keys in EK<sub>A,1</sub> and EK<sub>B</sub>, respectively.
- _EK<sub>A,n</sub><sup>public</sup>_ and _EK<sub>B,m</sub><sup>public</sup>_ denote the public keys in EK<sub>A,1</sub> and EK<sub>B</sub>, respectively.
- _DH(K<sub>1</sub><sup>public</sup>, K<sub>2</sub><sup>private</sup>)_ represents the shared key resulting from doing a Diffie-Hellman exchange with keys K<sub>1</sub> and K<sub>2</sub>.
- _KDF(KM)_ represents 32 bytes of output from the [HKDF algorithm](https://en.wikipedia.org/wiki/HKDF) with inputs:
  - HKDF input key material: _F || KM_, where KM is an input byte sequence containing secret key material, and F is a byte sequence filled 0xFF bytes whose length matches that of KM.
  - HKDF salt: A zero-filled byte sequence with length equal to the hash output length.
  - HKDF info: The channel id.

## Key Agreement Protocol

### Publishing Node Certificates

Per Relaynet Core, the node initiating the communication always has the certificate of its peer, so Alice will always have Bob's certificate. The distribution method is outside the scope of this document.

### Sending the Initial Message(s)

Alice MUST follow the following process when sending the first message(s) to Bob:

1. Generate the ephemeral asymmetric key EK<sub>A,1</sub>.
1. Calculate the shared key _SK<sub>1</sub> = KDF(KM)_, where KM = DH(LK<sub>B</sub><sup>public</sup>, EK<sub>A,1</sub><sup>private</sup>)).
1. Store SK<sub>1</sub> so it can be used to decrypt messages from Bob.
1. Encrypt each message to Bob with SK<sub>1</sub>, and attach the following data:
   - Alice' internal id for SK<sub>1</sub> (for example, a UUID4 value).
   - EK<sub>A,1</sub><sup>public</sup>.
   - The expiry date of EK<sub>A,1</sub>.

SK<sub>1</sub> MUST continue to be used until an ephemeral key from Bob is received. Until then, any message from Alice to Bob will be regarded an initial message.

### Receiving the Initial Message(s)

Bob MUST follow the following process when receiving an initial message from Alice:

1. Store EK<sub>A,1</sub><sup>public</sup> in order to send messages to Alice in the future, unless there is a previous ephemeral key from Alice that expires at a later date.
1. Calculate the shared key _SK<sub>1</sub> = KDF(DH(EK<sub>A,1</sub><sup>public</sup>, LK<sub>B</sub><sup>private</sup>))_.
1. Decrypt the message.

## Key Management Protocol

Alice and Bob MUST follow the following algorithm to exchange subsequent messages. Note that _X_ and _Y_ correspond to the sender and the recipient, respectively (Alice and Bob, or Bob and Alice).

### Sending Subsequent Messages

1. Generate the ephemeral asymmetric key EK<sub>X,m</sub> and store it, or retrieve it if a pre-existing one can be used.
1. Retrieve the peer' last ephemeral key EK<sub>Y,n</sub><sup>public</sup>.
1. Calculate the shared key _SK<sub>p</sub> = KDF(KM)_, where KM = DH(LK<sub>Y,n</sub><sup>public</sup>, EK<sub>X,m</sub><sup>private</sup>)).
1. Encrypt each message with SK<sub>p</sub>, and attach the following data:
   - The internal id for SK<sub>p</sub>.
   - EK<sub>X,m</sub><sup>public</sup>.
   - The expiry date of EK<sub>X,m</sub>.

### Receiving Subsequent Messages

1. Store EK<sub>X,1</sub><sup>public</sup> in order to send messages to their peer in the future, unless there is a previous ephemeral key from the peer that expires at a later date.
1. Calculate the shared key _SK<sub>p</sub> = KDF(DH(EK<sub>X,1</sub><sup>public</sup>, LK<sub>Y</sub><sup>private</sup>))_.
1. Decrypt the message.

### Expiry Ephemeral Keys

The sender MUST NOT use ephemeral keys for encryption after their expiry date. However, expired ephemeral keys MUST continue to be used for decryption during a grace period determined by the channel in order to make the sessions delay-tolerant.

As a consequence, the send MUST generate new ephemeral keys before any active ephemeral keys expire.

The sender MUST securely ephemeral keys as soon as the grace period lapses, to guarantee perfect forward secrecy.

## Notes

Note that unlike the X3DH protocol, long-term keys (known as identity keys in X3DH) are not input to the shared secret algorithm. In Signal, identity keys must be included to ensure mutual authentication, but in this case, the ciphertext itself will be part of the plaintext of a digital signature using the long-term keys (per [RAMF](rs001-ramf.md)).

## Limitations

This protocol will not work with unidirectional communication as might be the case between two endpoints (if one of the endpoints is private and does not issue Parcel Delivery Authorizations to its peer). Consequently, a Relaynet service with one-way communication would not get perfect forward secrecy or future secrecy, unless they enable two-way communication as a workaround until there is an equivalent protocol for unidirectional communication.
