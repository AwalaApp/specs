---
permalink: /RS-003
---
# Awala Channel Session Protocol
{: .no_toc }

- Id: RS-003.
- Status: Working draft.
- Type: Implementation.
- Issue tracking label: [`spec-channel-session`](https://github.com/AwalaNetwork/specs/labels/spec-channel-session).

## Abstract
{: .no_toc }

This document describes an asynchronous key agreement and management protocol to establish and maintain secure sessions in bidirectional [messaging channels](rs000-core.md#messaging-protocols). Its purpose is to add perfect forward secrecy, [future secrecy](https://signal.org/blog/advanced-ratcheting/) and replay attack mitigation to [endpoint](rs000-core.md#endpoint-messaging-protocol) and [gateway channels](rs000-core.md#gateway-messaging-protocol).

## Table of contents
{: .no_toc }

1. TOC
{:toc}

## Introduction

Awala Core defines messaging channels that use end-to-end encryption to guarantee confidentiality. But since messages are always encrypted using the same keys, compromising the keys will compromise past and future messages -- In other words, Awala Core does not offer perfect forward secrecy.

This protocol extends Awala to add perfect forward secrecy, future secrecy and replay attack mitigation. It is heavily based on the [Extended Triple Diffie-Hellman protocol](https://signal.org/docs/specifications/x3dh/) and the [double ratchet algorithm](https://signal.org/docs/specifications/doubleratchet/) from the Signal project, with some notable differences:

- There is no central server that can provide public keys for any node in Awala, but that is not necessary because peers always have each other's public keys. For example, a client-side application will be distributed with the public key of the server-side endpoint, and similarly, private gateways could be distributed with the public key of their Internet gateway (or provided by a trusted courier in a cargo relay connection).
- This protocol must be [tolerant to disruptions](https://en.wikipedia.org/wiki/Delay-tolerant_networking): Messages are most likely to arrive late, in batches and out of order, or they may be lost.
- This protocol is not limited to the X25519 and X448 curves, or the HMAC-based Extract-and-Expand Key Derivation Function (HKDF) from RFC 5869. To lower the barrier to adoption, algorithms that are more widely available are also supported.

The end result is a key agreement and management protocol where ephemeral keys are rotated as the recipient acknowledges the receipt of the previous ephemeral key.

## Roles

This document refers to the two nodes in the session as _Alice_ and _Bob_, and assumes that Alice wants to initiate a session with Bob.

Since this protocol applies to sessions on Awala channels, Alice and Bob MUST be either endpoints or gateways, but not a combination of the two -- That is, this protocol does not apply to [bindings](rs000-core.md#message-transport-bindings).

## Parameters

A channel implementation MUST specify the following parameters:

- Key exchange algorithm: Any key exchange algorithm allowed by [RS-018](rs018-algorithms.md).
- Key-derivation function (KDF): Any function allowed by [RS-018](rs018-algorithms.md).
- Cipher: Any cipher allowed by [RS-018](rs018-algorithms.md).
- Cryptographic hashing function: Any function allowed by [RS-018](rs018-algorithms.md).
- Channel id: An ASCII string identifying the channel. This is only needed when using HKDF as the KDF.

For example, a Awala service may configure its endpoints to use ECDH with P-256 as the key exchange algorithm, X9.63 as the KDF, AES-128 (KW and GCM) as the cipher, SHA-256 as the hashing function and `My Service` as the channel id.

## Notation

- _X \|\| Y_ denotes the concatenation of byte sequences X and Y.
- _K<sub>a,n</sub>_ denotes the n-th DH key pair generated by Alice. _K<sub>a,n</sub><sup>private</sup>_ and _K<sub>a,n</sub><sup>public</sup>_ denote its private and public keys, respectively, and _K<sub>a,n</sub><sup>id</sup>_ denotes the identifier of the key pair.
- _K<sub>b,n</sub>_ denotes the n-th DH key pair generated by Bob. _K<sub>b,n</sub><sup>private</sup>_ and _K<sub>b,n</sub><sup>public</sup>_ denote its private and public keys, respectively, and _K<sub>b,n</sub><sup>id</sup>_ denotes the identifier of the key pair.
- _DH(K<sub>1</sub><sup>public</sup>, K<sub>2</sub><sup>private</sup>)_ represents the shared key resulting from doing an [ephemeral-static Diffie-Hellman exchange](https://tools.ietf.org/html/rfc2631#section-2.3) with keys K<sub>1</sub> and K<sub>2</sub>.
- _KDF(KM)_ represents 32 bytes of output from the KDF. When using X9.63, the input MUST be as specified in [Section 4.3 of RFC 6318](https://tools.ietf.org/html/rfc6318#section-4.3). When using HKDF, the inputs MUST be:
  - Input key material: _F \|\| KM_, where KM is an input byte sequence containing secret key material, and F is a byte sequence filled with `0xFF` bytes whose length matches that of KM.
  - Salt: A zero-filled byte sequence with length equal to the hash output length.
  - Info: The channel id.

## Key Agreement Protocol

This protocol describes the initial interaction between Alice and Bob, which is used to establish a secure channel between the two.

Once the session has been established, both parties MUST reject incoming messages outside the session (i.e., any message not using the Channel Session Protocol or the expected DH keys). However, they MAY agree to start a new session.

### Generating and Distributing Initial DH Keys

Alice MUST have Bob's initial DH key K<sub>b,1</sub><sup>public</sup> and its id K<sub>b,1</sub><sup>id</sup> before running this protocol.

The initial DH key K<sub>b,1</sub> MUST be _ephemeral_ (i.e., only usable by Alice) unless Bob is a server, in which case the key MAY be _static_ (i.e., usable by any node) as it may not be possible to distribute ephemeral keys in advance. Regardless of their type, keys MUST NOT be valid for more than 60 days and they SHOULD NOT be valid for more than 30 days.

The initial key MUST be valid in the chosen key exchange algorithm. For example, the initial DH key must be 2048-bit if the session uses DH with a 2048-bit group; similarly, the initial DH key must be X25519 if the session uses ECDH with X25519.

### Sending Initial Message(s)

Alice MUST follow the following process when sending an initial message to Bob using his initial DH key (K<sub>b,1</sub><sup>public</sup>):

1. Generate the ephemeral asymmetric key K<sub>a,1</sub>.
1. Generate the unique id K<sub>a,1</sub><sup>id</sup> randomly or as the cryptographic digest of K<sub>a,1</sub><sup>public</sup>.
1. Store K<sub>a,1</sub><sup>private</sup> and K<sub>a,1</sub><sup>id</sup> so that they can be used to decrypt future messages from Bob.
1. Calculate the shared key _SK<sub>1</sub> = KDF(KM)_, where KM = DH(K<sub>b,1</sub><sup>public</sup>, K<sub>a,1</sub><sup>private</sup>).
1. Encrypt the plaintext with SK<sub>1</sub>.
1. Attach K<sub>a,1</sub><sup>public</sup>, K<sub>a,1</sub><sup>id</sup> and K<sub>b,1</sub><sup>id</sup> to the resulting ciphertext as metadata.

Alice MUST continue to use SK<sub>1</sub> to encrypt future messages until the first ephemeral key from Bob (K<sub>b,2</sub><sup>public</sup>) is received. Once that happens, any subsequent message from Alice to Bob MUST use the [algorithm to send subsequent message](#sending-subsequent-messages).

### Receiving Initial Message(s)

Bob MUST follow the following process when receiving an initial message from Alice:

1. Check that the required input is present, or else abort:
   - The ciphertext.
   - K<sub>a,1</sub><sup>public</sup>.
   - K<sub>a,1</sub><sup>id</sup>.
   - K<sub>b,1</sub><sup>id</sup>.
1. Retrieve K<sub>b,1</sub> by its id K<sub>b,1</sub><sup>id</sup>, or abort if it cannot be found.
1. Calculate the shared key _SK<sub>1</sub> = KDF(DH(K<sub>a,1</sub><sup>public</sup>, K<sub>b,1</sub><sup>private</sup>))_.
1. Decrypt the ciphertext with SK<sub>1</sub>, or abort if it fails to be decrypted.
1. Store K<sub>a,1</sub><sup>public</sup> along with K<sub>a,1</sub><sup>id</sup> in order to send messages to Alice in the future.

Upon successful completion of this process,
Bob MAY send messages to Alice using the [algorithm to send subsequent message](#sending-subsequent-messages).

## Key Management Protocol

Alice and Bob MUST follow the following algorithm to exchange subsequent messages. Note that _X_ and _Y_ correspond to the sender and the recipient, respectively (Alice and Bob, or Bob and Alice).

### Sending Subsequent Messages

The sender _X_ MUST follow the following process when sending a subsequent message to _Y_:

1. Compute K<sub>x,m</sub>:
   - Reuse the last ephemeral key K<sub>x,m-1</sub> if no incoming message from Y has used it; this could mean that Y has not received K<sub>x,m-1</sub> yet. This reuse is an optional performance optimization, as X would have fewer keys to manage.
   - Otherwise:
     1. Generate a new ephemeral key K<sub>x,m</sub>.
     1. Generate the unique id K<sub>x,m</sub><sup>id</sup> randomly or as the cryptographic digest of K<sub>x,m</sub><sup>public</sup>.
     1. Store K<sub>x,m</sub><sup>private</sup> and K<sub>x,m</sub><sup>id</sup> so that they can be used to decrypt future messages from Y.
1. Retrieve Y's last ephemeral key K<sub>y,n</sub><sup>public</sup> along with its id K<sub>y,n</sub><sup>id</sup>.
1. Calculate the shared key _SK<sub>p</sub> = KDF(KM)_, where KM = DH(K<sub>y,n</sub><sup>public</sup>, K<sub>x,m</sub><sup>private</sup>).
1. Encrypt the plaintext with SK<sub>p</sub>.
1. Attach K<sub>x,m</sub><sup>public</sup>, K<sub>x,m</sub><sup>id</sup> and K<sub>y,n</sub><sup>id</sup> to the resulting ciphertext as metadata.

### Receiving Subsequent Messages

The recipient Y MUST follow the following process when receiving a subsequent message from X:

1. Check that the required input is present, or else abort:
   - The ciphertext.
   - K<sub>x,m</sub><sup>public</sup>.
   - K<sub>x,m</sub><sup>id</sup>.
   - K<sub>y,n</sub><sup>id</sup>.
1. Retrieve K<sub>y,n</sub> by its id K<sub>y,n</sub><sup>id</sup>, or abort if it cannot be found.
1. Calculate the shared key _SK<sub>p</sub> = KDF(DH(K<sub>x,m</sub><sup>public</sup>, K<sub>y,n</sub><sup>private</sup>))_.
1. Decrypt the ciphertext with SK<sub>p</sub>, or abort if it fails to be decrypted.
1. Store K<sub>x,m</sub><sup>public</sup> along with K<sub>x,m</sub><sup>id</sup> in order to send messages to X in the future, unless a different key was already used in a newer message; keep in mind that messages may arrive out of order.
1. If K<sub>y,n</sub> was the last key generated by Y, then delete any rotated key K<sub>y,n-1</sub> in order to achieve forward secrecy and future secrecy. This deletion MAY be deferred until the next incoming [relay](rs000-core.md#cargo-relay-binding) so that any in-transit messages using the rotated key can be decrypted.

## CMS EnvelopedData Representation

When using a [CMS EnvelopedData](https://tools.ietf.org/html/rfc5652#section-6) value to encapsulate ciphertext encrypted with these DH keys, implementations MUST comply with the following RFCs depending on the specific DH algorithm used:

- When using ECDH, the EnvelopedData value MUST be serialized as described in [RFC 5753](https://tools.ietf.org/html/rfc5753.html). Additionally, the implementation MUST comply with [RFC 8418](https://tools.ietf.org/html/rfc8418) when using X25519 or X448.
- When using (finite field) DH, the implementation MUST comply with [Section 4.1.1 of RFC 3370](https://tools.ietf.org/html/rfc3370#section-4.1.1).

Amongst other things, the RFCs above require the [`RecipientInfo`](https://tools.ietf.org/html/rfc5652#section-6.2) to use the [`KeyAgreeRecipientInfo`](https://tools.ietf.org/html/rfc5652#section-6.2.2) choice. They also require K<sub>a,1</sub><sup>public</sup> or K<sub>x,m</sub><sup>public</sup> to be stored as the originator's public key, and K<sub>b,1</sub><sup>id</sup> or K<sub>y,n</sub><sup>id</sup> to be stored as the recipient's ephemeral key identifier.

Implementations MUST store the recipient's ephemeral key identifier in the `subjectKeyIdentifier` choice of the `KeyAgreeRecipientIdentifier`. They MUST also store the originator's ephemeral key identifier (K<sub>a,1</sub><sup>id</sup> or K<sub>x,m</sub><sup>id</sup>) under the `unprotectedAttrs` field of the EnvelopedData value as the integer representation of the corresponding serial number and use the following OID:

```
OriginatorEphemeralKeyId OBJECT IDENTIFIER ::= { awala channel-session(1) 0 }
```

## Limitations

This protocol will not work with unidirectional communication as might be the case between two endpoints (if one of the endpoints is private and does not issue Parcel Delivery Authorizations to its peer). Consequently, an Awala service with one-way communication would not get perfect forward secrecy or future secrecy, unless it enables two-way communication as a workaround until there is an equivalent protocol for unidirectional communication.

## Relevant Specifications

[RS-018 (Cryptographic Algorithms)](rs018-algorithms.md) defines the requirements and recommendations for the use of cryptographic algorithms in Awala.
